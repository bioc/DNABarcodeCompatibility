---
title: "Introduction to DNABarcodeCompatibility"
author: "Céline Trébeau & Raphaël Etournay"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
<style>
body {
text-align: justify}
</style>


```{r setup, include = FALSE}

  
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(width=120)
```

This document introduces you to DNABarcodeCompatibility’s basic set of tools.     

The DNABarcodeCompatibility package provides six functions and two barcode datasets for running examples. The functions allow one to load DNA barcodes, to generate, filter and optimize sets of compatible barcode combinations for multiplex sequecing experiments. In particular, the package provides an optimizer function to further favor the selection of compatible barcode combinations with **least redundancy of DNA barcodes** and allows one to keep barcodes that are **robust against substitution and insertion/deletion errors** thereby facilitating the demultiplexing step.      

This package contains:

* one workflow called `experiment_design()` to perfom all steps in one go
* two datasets called `IlluminaIndexesRaw` and `IlluminaIndexes` for running examples
* a series of API to build your own workflow     

This package deals with the three existing sequencing-by-synthesis chemistries from Illumina:

* Four-Channel SBS Chemistry: MiSeq, HiSeq systems
* Two-Channel SBS Chemistry: MiniSeq, NextSeq, NovaSeq systems
* One-Channel SBS Chemistry: iSeq system    


## Load the package

```{r, echo=TRUE}
library("DNABarcodeCompatibility")
```

## Define a helper function to save the raw dataset as a temporary text file

```{r, echo=TRUE}
# This function is created for the purpose of the documentation 
export_dataset_to_file = function(dataset = DNABarcodeCompatibility::IlluminaIndexesRaw) {
  if (class(dataset)=="data.frame") {
    write.table(dataset,
                textfile <- tempfile(), row.names = FALSE, col.names = FALSE, quote=FALSE)
    return(textfile)
  } else print("The input dataset isn't a data.frame: NOT exported into file")
}
```


## Design an experiment 

The function `experiment_design()` uses a Shannon-entropy maximization approach to identify a set of compatible barcode combinations with least redundancy between DNA barcodes, in the contexts of single and dual barcoding. It performs either an exhaustive or a random search of compatible DNA-barcode combinations depending on the size of the DNA-barcode population and of the number of samples to be multiplexed.

### Examples for single indexing

* 12 libraries sequenced in multiplex of 3 on a HiSeq (4 channels) platform
```{r, echo=TRUE}
txtfile <- export_dataset_to_file(dataset = DNABarcodeCompatibility::IlluminaIndexesRaw)
experiment_design(file1=txtfile, sample_number=12, mplex_level=3, chemistry=4)
```

* 12 libraries sequenced in multiplex of 3 on a NextSeq (2 channels) platform
```{r, echo=TRUE}
txtfile <- export_dataset_to_file(dataset = DNABarcodeCompatibility::IlluminaIndexesRaw)
experiment_design(file1=txtfile, sample_number=12, mplex_level=3, chemistry=2)
```

* 12 libraries sequenced in multiplex of 3 on a iSeq (1 channels) platform
```{r, echo=TRUE}
txtfile <- export_dataset_to_file(dataset = DNABarcodeCompatibility::IlluminaIndexesRaw)
experiment_design(file1=txtfile, sample_number=12, mplex_level=3, chemistry=1)
```

* 12 libraries sequenced in multiplex of 3 on a HiSeq platform using barcodes robust against 1 substitution error
```{r, echo=TRUE}
txtfile <- export_dataset_to_file(dataset = DNABarcodeCompatibility::IlluminaIndexesRaw)
experiment_design(file1=txtfile, sample_number=12, mplex_level=3, chemistry=4, metric = "hamming", d = 3)

```

### Examples for dual indexing


* 12 libraries sequenced in multiplex of 3 on a HiSeq platform
```{r, echo=TRUE}
# Select the first half of barcodes from the dataset
txtfile1 <- export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexesRaw[1:24,])

# Select the second half of barcodes from the dataset
txtfile2 <- export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexesRaw[25:48,])

# Get compatibles combinations of least redundant barcodes
experiment_design(file1=txtfile1, sample_number=12, mplex_level=3, chemistry=4, file2=txtfile2)
```

* 12 libraries sequenced in multiplex of 3 on a HiSeq platform using barcodes robust against 1 substitution error
```{r, echo=TRUE}
# Select the first half of barcodes from the dataset
txtfile1 <- export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexesRaw[1:24,])

# Select the second half of barcodes from the dataset
txtfile2 <- export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexesRaw[25:48,])

# Get compatibles combinations of least redundant barcodes
experiment_design(file1=txtfile1, sample_number=12, mplex_level=3, chemistry=4, file2=txtfile2, metric="hamming", d=3)
```


## Buid your own workflow

This section guides you through the detailed API of the package with the aim to build your own workflow. This will give you more flexibility than the `experiment_design()` function.

### Load and check a dataset of barcodes

The `file_loading_and_checking()` function loads the file containing the DNA barcodes and analyzes its content. In particular, it checks barcodes for unicity (identifier and sequence), DNA content, and equal size. It also calculates the GC content and detects the presence of homopolymers of length >= 3.

```{r, echo=TRUE}
file_loading_and_checking(file = export_dataset_to_file(dataset = DNABarcodeCompatibility::IlluminaIndexesRaw))
```

### Examples of an exhaustive search of compatible barcode combinations

The total number of combinations depends on the number of available barcodes and of the multiplex level. For 48 barcodes and a multiplex level of 3, the total number of combination can be calculated using `choose(48,3)`, namely 17296 combinations. However, in many cases the total number of combinations can become gigantic and you must not perform an exhaustive search (see `get_random_combinations()` below).

* 48 barcodes, multiplex level of 2, HiSeq plateform
```{r, echo=TRUE}
# Total number of combinations
choose(48,2)

# Load barcodes
barcodes <- DNABarcodeCompatibility::IlluminaIndexes

# Time for an exhaustive search
system.time(m <- get_all_combinations(index_df = barcodes, mplex_level = 2, chemistry = 4))

# Each line represents a compatible combination of barcodes
head(m)

```

* 48 barcodes, multiplex level of 3, HiSeq plateform
```{r, echo=TRUE}
# Total number of combinations
choose(48,3)

# Load barcodes
barcodes <- DNABarcodeCompatibility::IlluminaIndexes

# Time for an exhaustive search
system.time(m <- get_all_combinations(index_df = barcodes, mplex_level = 3, chemistry = 4))

# Each line represents a compatible combination of barcodes
head(m)

```

### Examples of a random search of compatible barcode combinations

When the total number of combinations becomes high, it is recommended to pick combinations at random and then select those that are compatible. 

* 48 barcodes, multiplex level of 3, HiSeq plateform
```{r, echo=TRUE}
# Total number of combinations
choose(48,3)

# Load barcodes
barcodes <- DNABarcodeCompatibility::IlluminaIndexes

# Time for a random search
system.time(m <- get_random_combinations(index_df = barcodes, mplex_level = 2, chemistry = 4))

# Each line represents a compatible combination of barcodes
head(m)

```

* 48 barcodes, multiplex level of 4, HiSeq plateform
```{r, echo=TRUE}
# Total number of combinations
choose(48,4)

# Load barcodes
barcodes <- DNABarcodeCompatibility::IlluminaIndexes

# Time for a random search
system.time(m <- get_random_combinations(index_df = barcodes, mplex_level = 4, chemistry = 4))

# Each line represents a compatible combination of barcodes
head(m)

```

* 48 barcodes, multiplex level of 6, HiSeq plateform
```{r, echo=TRUE}
# Total number of combinations
choose(48,6)

# Load barcodes
barcodes <- DNABarcodeCompatibility::IlluminaIndexes

# Time for a random search
system.time(m <- get_random_combinations(index_df = barcodes, mplex_level = 6, chemistry = 4))

# Each line represents a compatible combination of barcodes
head(m)

```

### Constrain barcodes to be robust against one substitution error 


```{r, echo=TRUE}
# Load barcodes
barcodes <- DNABarcodeCompatibility::IlluminaIndexes

# Perform a random search of compatible combinations
m <- get_random_combinations(index_df = barcodes, mplex_level = 3, chemistry = 4)

# Keep barcodes that are robust against one substitution error
filtered_m <- distance_filter(index_df = barcodes, combinations_m = m, metric = "hamming", d = 3)

# Each line represents a compatible combination of barcodes
head(filtered_m)
```

### Optimize the set of compatible combinations to reduce barcode redundancy between lanes

```{r, echo=TRUE}
# Keep set of compatible barcodes that are robust against one substitution error
filtered_m <- distance_filter(index_df = DNABarcodeCompatibility::IlluminaIndexes,
                              combinations_m = get_random_combinations(index_df = barcodes, mplex_level = 3, chemistry = 4),
                              metric = "hamming", d = 3)

# Use a Shannon-entropy maximization approach to reduce barcode redundancy
df <- optimize_combinations(combination_m = filtered_m, nb_lane = 12, index_number = 48)

# Each line represents a compatible combination of barcodes and each row a lane of the flow cell
df
```

### The optimized result cannot be an optimum when filtering out too many barcodes

* Increased distance between barcode sequences: redundancy may become inevitable
```{r, echo=TRUE}
# Keep set of compatible barcodes that are robust against multiple substitution and insertion/deletion errors
filtered_m <- distance_filter(index_df = DNABarcodeCompatibility::IlluminaIndexes,
                              combinations_m = get_random_combinations(index_df = barcodes, mplex_level = 3, chemistry = 4),
                              metric = "seqlev", d = 4)

# Use a Shannon-entropy maximization approach to reduce barcode redundancy
df <- optimize_combinations(combination_m = filtered_m, nb_lane = 12, index_number = 48)

# Each line represents a compatible combination of barcodes and each row a lane of the flow cell
df
```