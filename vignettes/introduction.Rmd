---
title: "Introduction to DNABarcodeCompatibility"
author: "Céline Trébeau & Raphaël Etournay"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This document introduces you to DNABarcodeCompatibility’s basic set of tools. 

The DNABarcodeCompatibility package provides six functions to load DNA barcodes, and to generate, filter and optimize sets of compatible barcode combinations for multiplex sequecing experiments. In particular, barcode combinations can be filtered to keep those that are robust against substitution and insertion/deletion errors thereby facilitating the demultiplexing step. In addtion, the package provides an optimizer function to further favor the selection of compatible barcode combinations with least redundancy of DNA barcodes.

This package contains:

* a dataset called `IlluminaIndexes` for running examples
* one workflow called `experiment_design()` to perfom all steps in one go
* a series of API to build your own workflow

## Load the package

```{r, echo=TRUE}
library("DNABarcodeCompatibility")
```

## Load the example dataset and save as text file: `txtfile`

```{r, echo=TRUE}
head(DNABarcodeCompatibility::IlluminaIndexes)

export_dataset_to_file = function(dataset=DNABarcodeCompatibility::IlluminaIndexes) {
  if (class(dataset)=="data.frame") {
    write.table(dataset,
                textfile <- tempfile(), row.names = FALSE, col.names = FALSE, quote=FALSE)
    print("Dataset successfully exported into a file.")
    return(textfile)
  } else print("The input dataset isn't a data.frame: NOT exported into file")
}

```


## Design an experiment 

The function `experiment_design()` uses the Shannon Entropy to identify a set of compatible barcode combinations with least redundancy between DNA barcodes, in the contexts of single and dual indexing. It performs either an exhaustive or a random search of compatible DNA-barcode combinations depending on the size of the DNA-barcode population and of the number of samples to be multiplexed.

### Single indexing

* 18 libraries sequenced in multiplex of 3 on a HiSeq (4 channels) platform
```{r, echo=TRUE}
txtfile <- export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes)
experiment_design(file1=txtfile, sample_number=18, mplex_level=3, chemistry=4)
```

* 12 libraries sequenced in multiplex of 3 on a NextSeq (2 channels) platform
```{r, echo=TRUE}
txtfile <- export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes)
experiment_design(file1=txtfile, sample_number=12, mplex_level=3, chemistry=2)
```

* 18 libraries sequenced in multiplex of 3 on a HiSeq (4 channels) platform using barcode robust againt 1 substitution error
```{r, echo=TRUE}
txtfile <- export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes)
experiment_design(file1=txtfile, sample_number=18, mplex_level=3, chemistry=4, metric = "hamming", d = 3)

```

### Dual indexing


* 18 libraries sequenced in multiplex of 3 on a HiSeq (4 channels) platform
```{r, echo=TRUE}
# Select the first half of barcodes from the dataset
txtfile1 <- export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes[1:24,])

# Select the second half of barcodes from the dataset
txtfile2 <- export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes[25:48,])

# Get compatibles combinations of least redundant barcodes
experiment_design(file1=txtfile1, sample_number=18, mplex_level=3, chemistry=4, file2=txtfile2)
```

* 18 libraries sequenced in multiplex of 3 on a HiSeq (4 channels) platform, robust againts substitution errors
```{r, echo=TRUE}
# Select the first half of barcodes from the dataset
txtfile1 <- export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes[1:24,])

# Select the second half of barcodes from the dataset
txtfile2 <- export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes[25:48,])

# Get compatibles combinations of least redundant barcodes
experiment_design(file1=txtfile1, sample_number=18, mplex_level=3, chemistry=4, file2=txtfile2, metric="hamming", d=3)
```


## Buid your own workflow

This section guides you through the detailed API of the package with the aim to build your own workflow. This will give you more flexibility than the `experiment_design()` function.

### Load and check a dataset of barcodes

The `file_loading_and_checking()` function loads the file containing the DNA barcodes and analyzes its content. In particular, it checks barcodes for unicity (identifier and sequence), DNA content, and equal size. It also calculates the GC content and detects the presence of homopolymers of length >= 3.

```{r, echo=TRUE}
barcodes <- file_loading_and_checking(export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes))
head(barcodes)
```

### Perform an exhaustive search of compatible barcode combinations

The total number of combinations depends on the number of available barcodes and of the multiplex level. For 48 barcodes and a multiplex level of 3, the total number of combination can be calculated using `choose(48,3)`, namely 17296 combinations. However, in many cases the total number of combinations can become gigantic and you must not perform an exhaustive search (see `get_random_combinations()` below).

* 48 barcodes, multiplex level of 2, 4-channel plateform
```{r, echo=TRUE}
# Total number of combinations
choose(48,2)

# Compatible combinations after an exhaustive search
barcodes <- file_loading_and_checking(export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes))
system.time(m <- get_all_combinations(index_df = barcodes, mplex_level = 2, chemistry = 4))
head(m)

```

* 48 barcodes, multiplex level of 3, 4-channel plateform
```{r, echo=TRUE}
# Total number of combinations
choose(48,3)

# Compatible combinations after an exhaustive search
barcodes <- file_loading_and_checking(export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes))
system.time(m <- get_all_combinations(index_df = barcodes, mplex_level = 3, chemistry = 4))
head(m)

```

### Perform a random search of compatible barcode combinations

When the total number of combinations becomes high, it is recommended to pick combinations at random and then select those that are compatible. 

* 48 barcodes, multiplex level of 3, 4-channel plateform
```{r, echo=TRUE}
# Total number of combinations
choose(48,3)

# Compatible combinations after an exhaustive search
barcodes <- file_loading_and_checking(export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes))
system.time(m <- get_random_combinations(index_df = barcodes, mplex_level = 2, chemistry = 4))
head(m)

```

* 48 barcodes, multiplex level of 4, 4-channel plateform
```{r, echo=TRUE}
# Total number of combinations
choose(48,4)

# Compatible combinations after an exhaustive search
barcodes <- file_loading_and_checking(export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes))
system.time(m <- get_random_combinations(index_df = barcodes, mplex_level = 4, chemistry = 4))
head(m)

```

* 48 barcodes, multiplex level of 6, 4-channel plateform
```{r, echo=TRUE}
# Total number of combinations
choose(48,6)

# Compatible combinations after an exhaustive search
barcodes <- file_loading_and_checking(export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes))
system.time(m <- get_random_combinations(index_df = barcodes, mplex_level = 6, chemistry = 4))
head(m)

```

### Constrain barcodes to be robust against one substitution error 


```{r, echo=TRUE}
barcodes <- file_loading_and_checking(export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes))
m <- get_random_combinations(index_df = barcodes, mplex_level = 3, chemistry = 4)
filtered_m <- distance_filter(index_df = barcodes, combinations_m = m, metric = "hamming", d = 4)
head(filtered_m)
```

### Optimize the set of compatible combinations to reduce barcode redundancy between lanes

```{r, echo=TRUE}
filtered_m <- distance_filter(index_df = file_loading_and_checking(export_dataset_to_file(DNABarcodeCompatibility::IlluminaIndexes)),
                              combinations_m = get_random_combinations(index_df = barcodes, mplex_level = 3, chemistry = 4),
                              metric = "hamming", d = 3)
df <- optimize_combinations(combination_m = filtered_m, nb_lane = 12, index_number = 48)
head(df)
```
